{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\ncontroller_1 = Controller(PRIMARY)\nGrabber = Motor(Ports.PORT10, GearSetting.RATIO_18_1, False)\nRamp_motor_a = Motor(Ports.PORT1, GearSetting.RATIO_18_1, False)\nRamp_motor_b = Motor(Ports.PORT2, GearSetting.RATIO_18_1, False)\nRamp = MotorGroup(Ramp_motor_a, Ramp_motor_b)\nL_motor_a = Motor(Ports.PORT11, GearSetting.RATIO_18_1, True)\nL_motor_b = Motor(Ports.PORT14, GearSetting.RATIO_18_1, True)\nL = MotorGroup(L_motor_a, L_motor_b)\nR_motor_a = Motor(Ports.PORT13, GearSetting.RATIO_18_1, False)\nR_motor_b = Motor(Ports.PORT12, GearSetting.RATIO_18_1, False)\nR = MotorGroup(R_motor_a, R_motor_b)\nimu = Inertial(Ports.PORT7)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\n# Make random actually random\ndef initializeRandomSeed():\n    wait(100, MSEC)\n    random = brain.battery.voltage(MV) + brain.battery.current(CurrentUnits.AMP) * 100 + brain.timer.system_high_res()\n    urandom.seed(int(random))\n      \n# Set random seed \ninitializeRandomSeed()\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n#endregion VEXcode Generated Robot Configuration\nimport math\nimport time\n\n# Set velocities\nL.set_velocity(100, PERCENT)\nR.set_velocity(100, PERCENT)\nRamp.set_velocity(100, PERCENT)\nGrabber.set_velocity(100, PERCENT)\n\n# Brake settings\nL.set_stopping(BRAKE)\nR.set_stopping(BRAKE)\nGrabber.set_stopping(BRAKE)\nRamp.set_stopping(BRAKE)\n\n# Gear ratio and wheel settings\nwheel_diameter = 4.0  # in inches\ngear_ratio = 36.0 / 84.0  # output/input gear ratio\ntrack_width = 6.0  # distance between wheels in inches\n\n# Conversion factor for motor degrees to distance in inches\ndef motor_degrees_to_distance(degrees):\n    wheel_circumference = math.pi * wheel_diameter\n    return (degrees / 360) * wheel_circumference * gear_ratio\n\n# Define grabber and ramp functions\ndef grabber_button():\n    Grabber.spin_to_position(180, DEGREES)\n    while not Grabber.is_spinning():\n        Grabber.stop()\n\ndef grabber_button2():\n    Grabber.spin_to_position(0, DEGREES)\n    while not Grabber.is_spinning():\n        Grabber.stop()\n\ndef ramp_forward():\n    Ramp.spin(FORWARD)\n\ndef ramp_backwards():\n    Ramp.spin(REVERSE)\n\ndef ramp_stop():\n    Ramp.stop()\n\n# PID class for controlling the motors\nclass PID:\n    def __init__(self, kP, kI, kD, setpoint):\n        self.kP = kP\n        self.kI = kI\n        self.kD = kD\n        self.setpoint = setpoint\n        self.previous_error = 0\n        self.integral = 0\n        self.output = 0\n        self.last_time = brain.timer.time(SECONDS)\n\n    def update(self, measured_value):\n        current_time = brain.timer.time(SECONDS)\n        dt = current_time - self.last_time\n        self.last_time = current_time\n\n        error = self.setpoint - measured_value\n        proportional = self.kP * error\n\n        self.integral += error * dt\n        integral = self.kI * self.integral\n\n        derivative = self.kD * (error - self.previous_error) / dt if dt > 0 else 0\n        self.previous_error = error\n\n        self.output = proportional + integral + derivative\n        return self.output\n\n# Odometry update function using motor positions\nx, y, heading = 0, 0, 0\n\ndef update_odometry():\n    global x, y, heading\n\n    while True:\n        # Get the motor positions\n        left_position = motor_degrees_to_distance(L_motor_a.position(DEGREES))\n        right_position = motor_degrees_to_distance(R_motor_a.position(DEGREES))\n\n        # Calculate change in heading and forward movement\n        delta_left = left_position\n        delta_right = right_position\n        delta_heading = (delta_right - delta_left) / track_width\n\n        # Average distance traveled (forward)\n        forward_distance = (delta_left + delta_right) / 2\n\n        # Update heading\n        heading += delta_heading\n\n        # Calculate x and y changes\n        delta_x = forward_distance * math.cos(heading)\n        delta_y = forward_distance * math.sin(heading)\n\n        # Update x and y coordinates\n        x += delta_x\n        y += delta_y\n\n        wait(20, MSEC)\n\n# Drive a specified distance using PID control\ndef drive_distance(target_distance_inches):\n    target_counts = motor_degrees_to_distance(target_distance_inches)\n    L_motor_a.reset_position()\n    pid_controller = PID(kP=0.1, kI=0.01, kD=0.05, setpoint=target_counts)\n\n    while True:\n        measured_value = motor_degrees_to_distance(L_motor_a.position(DEGREES))\n        motor_output = pid_controller.update(measured_value)\n\n        L.set_velocity(motor_output, PERCENT)\n        R.set_velocity(motor_output, PERCENT)\n        L.spin(FORWARD)\n        R.spin(FORWARD)\n\n        if abs(measured_value) >= target_counts:\n            L.stop()\n            R.stop()\n            break\n\n        wait(20, MSEC)\n\n# Driver control function\ndef driver_control():\n    while True:\n        L.set_velocity(controller_1.axis3.position() + controller_1.axis4.position(), PERCENT)\n        R.set_velocity(controller_1.axis3.position() - controller_1.axis4.position(), PERCENT)\n        L.spin(FORWARD)\n        R.spin(FORWARD)\n        wait(20, MSEC)\n\n# Autonomous function\ndef autonomous():\n    drive_distance(60.0)  # Drive 60 inches\n\n# Set button events once (outside the main loop) to prevent \"no event resources\" error\ncontroller_1.buttonA.pressed(grabber_button)\ncontroller_1.buttonB.pressed(grabber_button2)\ncontroller_1.buttonUp.pressed(ramp_forward)\ncontroller_1.buttonDown.pressed(ramp_backwards)\ncontroller_1.buttonLeft.pressed(ramp_stop)\n\n# Start the odometry thread\nThread(update_odometry)\n\n# Define competition controls\ncompetition = Competition(driver_control, autonomous)\n","textLanguage":"python","robotConfig":[{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[10],"name":"Grabber","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[1,2],"name":"Ramp","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","gear":"ratio18_1","motor_a_reversed":"false","motor_b_reversed":"false","id":"partner"},"triportSourcePort":22},{"port":[11,14],"name":"L","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","gear":"ratio18_1","motor_a_reversed":"true","motor_b_reversed":"true"},"triportSourcePort":22},{"port":[13,12],"name":"R","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","gear":"ratio18_1","motor_a_reversed":"false","motor_b_reversed":"false","id":"partner"},"triportSourcePort":22},{"port":[7],"name":"imu","customName":true,"deviceType":"Inertial","deviceClass":"inertial","setting":{"id":"partner"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.0.5","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false}